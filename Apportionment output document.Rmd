---
title: "Apportionment simulations"
author: "Kari Fenske, Curry Cunningham, Dana Hanselman"
date: "August 16, 2019"
output: html_document
---


```{r, echo=FALSE, message=FALSE, warning=FALSE}
#install the libraries
require(dplyr)
require(reshape2)
require(tidyverse)
require(ggplot2)
#for extract-pars.R
#require(readxl)
require(xlsx)
# for sample-age-comps.R
require(gtools) 
#for .dat file building
require(PBSmodelling)
require(R2admb)

###THESE ITEMS NEED MANUAL INPUT!!!###
n.apports <- 6 #number of apportionment options that have been run and are to be compiled here
apports <- c(1,2,3,4,5,6)#,7,8,9,10,11) #the folder numbers of the apportionment options to be compiled
#"Equal-1","Fixed-2","Equilibrium-3","NPFMC-4","Exp_survey_wt-5","Exp_fishery_wt-6","Non-Exp_NPFMC-7",
#"Partial_fixed-8","Age_based-9","RandEff-10"","All_to_one-11","TermYear_biom-12","Penalized-13","Non-exp_Agebased-14"
apport.names <- list("Equal","Fixed","Equilibrium","NPFMC","Exp_survey_wt","Exp_fishery_wt")#,"Non-Exp_NPFMC",
#"Partial_fixed","Age_based","Term_LLsurv","All_to_one") #list the names of the apportionment options being compared


#read in the apportionment R object files for indexing
wd <- ("C:/Repositories/Sablefish_ApportionmentStrategies") #may need to manually enter your wd here
dir.output <- file.path(wd,"output/")
dir.admb <- file.path(wd,"admb")

#setwd(dir.output)
n.year <- readRDS(file.path(wd,"output","n.year.rds"))
years <- readRDS(file.path(wd,"output","years.rds"))
n.sims <- readRDS(file.path(wd,"output","n.sims.rds"))
sims <- readRDS(file.path(wd,"output","sims.rds"))
n.age <- readRDS(file.path(wd,"output","n.age.rds"))
ages <- readRDS(file.path(wd,"output","ages.rds"))
n.sex <- readRDS(file.path(wd,"output","n.sex.rds"))
sexes <- readRDS(file.path(wd,"output","sexes.rds"))
n.area <- readRDS(file.path(wd,"output","n.area.rds"))
areas <- readRDS(file.path(wd,"output","areas.rds"))
age.rec <- readRDS(file.path(wd,"output","age.rec.rds"))
A <- readRDS(file.path(wd,"output","A.rds"))
apport.opt <- readRDS(file.path(wd,"output","apport.opt.rds"))
n.fish <- readRDS(file.path(wd,"output","n.fish.rds"))
fish <- readRDS(file.path(wd,"output","fish.rds"))
n.surv <- readRDS(file.path(wd,"output","n.surv.rds"))
surv.name <- readRDS(file.path(wd,"output","surv.name.rds"))

#plotting things
forproj.styr <- 44 #define the year (y) where EM is first run 
OMyears <- c(1977:2018) #conditioning period years for OM
rpn_years <- c(15:43) #LL survey index years
rpw_years <- c(15:42) #fixed gear fishery years
mgmt_rep_years <- c(1960:2018) # these are the years for management EM data (for comparison plotting)

#read in data from single area management model/Kari's single model (it's sort of hybrid data)
mgmt_dat <- readList(file.path(dir.admb,"Single_area/permanant_tem_single2018.dat"))
#read in data from the single area mgmt report file
mgmt_rep <- readList(file.path(dir.admb,"Management/tem_simplified.rep"))
#read in data from the conditioning OM years
OM <- readList(file.path(dir.admb,"Single_area/tem_single2018.dat"))

#read in OM objects as you use them below
#read in EM objects as you use them below

```

# General information
Apportionment of sablefish ABC to management regions has been fixed at 2013 ratios since 2014. An objective of the analyses presented here is to examine pros and cons of a suite of sablefish ABC apportionment methods. This document presents the apportionment simulation work to date. This is a work in progress and we are seeking feedback on OM and EM set up, alternative performance metrics that would be useful in making apportionment method recommendations, and any other suggestions for simulation and model performance. Bonus points if you can suggest better ways to graph things.

These apportionment simulation analyses contain two primary components, a 6-area operating model (OM) and a 1-area estimation model (EM). The OM is spatial so that potential spatial dynamics in fleet or fish behavior (via catchability, selectivity, and fish movement) may be simulated. The OM simulates data in two periods - a deterministic conditioning period which occurs for years 1977-2018 and is the same across simulations, and a stochastic forward projecting portion which runs for years 2019-`r 1976+n.year-1`. The EM is similar to the EM used for sablefish management, but begins in 1977 instead of 1960, does not include length compositions, and does not fit a trawl survey. After the conditioning period data is generated in the OM, the OM population is sampled, and simulated data from the OM is combined into a single area dataset which is passed to the EM.  

In the forward projecting period, the OM-EM is iterative, looping through years. The order of operations for year y are: OM - Read in previous year's apportioned ABC by area, estimate the F required to catch ABC for each area, apply F and M to OM population, move fish between areas, sample the population for fishery and longline survey abundance indices and for longline survey and fixed gear fishery age compositions, build the .dat file and pass it to the EM in ADMB, run the EM and get an estimate of the next year's ABC (then repeat for the next year).

At present for each apportionment method we examine, we are running `r n.sims` simulations covering years 1977-`r 1976+n.year-1`. For November, we hope to present results for 100 (or more) simulated datasets each looping over years 2019-2049 (30 years for forward looping years).

There are some inherent assumptions in this simulation we would like to present up front:
1) We assume ABC=TAC and 100% of apportioned ABC is caught in each region.  
2) We do not correct for whale depredation in the ABC or survey index.  
3) Recruitment occurs at age 2 and recruitment is split equally between males and females.  
     

# Alternative apportionment scenarios 
In the analyses presented in this document we examine `r n.apports` apportion methods: `r apport.names`. A shorthand summary of what each apportioment method does is below.
1 - Equal: Each region receives 1/6 of the ABC.  
2 - Fixed: The apportionment proportions from the 2013 assessment that have been applied as fixed proportions for 2014-2018.   
3 - Equilibrium: Based on the stationary distribution of the movement rates.  
4 - NPFMC: A 5-yr exponentially weighted moving average of fishery and survey indices; survey weight is 2x fishery weight.    
5 - Exp_survey_wt: Similar to ‘NPFMC’ option but using survey index only.  
6 - Exp_fishery_wt: Similar to ‘NPFMC’ option but using fishery index only.   
7 - Non-Exp_NPFMC: A 5-yr moving average of fishery and survey indices.  
8 - Partial_fixed: BS and AI receive 10% of the ABC each, WG, CG, WY, and EY are apportioned based on NPFMC method.    
9 - Age_based: Based on the proportions of fish at age of 50% maturity in each area - i.e. areas with greater proportion of fish at age of 50% maturity or greater will be apportioned a greater proportion of ABC.    
10 - Term_LLsurv: Terminal year of longline survey (no exponential weighting).   

``` {r, echo=FALSE}
#these are a few apportionment options we've considered and may do, but either are for internal (research) use, aren't a priority, or aren't yet functioning. 
#10 - RandEff (Apportionment to region based on the proportions of biomass estimated by the RE model applied to the longline survey, using 0.05 CV)    
#11 - All_to_one (all apportionment to one area - for research purposes of showing extremes ONLY)  
#12 - TermYear_biom (Based on terminal year survey biomass)  
#13 - Penalized 
#14 - Non-exp_Agebased  
```

# OM Conditioning period
The OM model set up begins by establishing initial numbers at age for each area in 1976. Initial N for 1976 is input as the 2018 management EM totaly abundance estimated for 1977. This is split into `r n.area` spatial areas using the proportion of abundance by area from the longline survey abundance estimate and split into initial age and sex proportions using proportion by sex and age from 2018 management EM for 1976 numbers at age. Numbers at age are conveted to biomass at age using the age-weight relationship as described in the sablefish 2018 SAFE report.

OM conditioning period is deterministic and the same for all simulation iterations. Movement is specified between `r n.area` and the OM is set up to accommodate age-based movement; however, at present movement is un-varying over ages. During the OM conditioning period recruitment is input from the EM, and catch is input and the F which generated that catch estimated and applied to the population. Please see the Appendix for OM population dynamics equations.  

Movement rates used in the OM are externally generated and based on the Hanselman et al. (2015) sablefish movement paper. The model described in the paper was re-run for `r n.area` areas and those movement values are input. 

Table 1: Movement rates used in the OM are based on 30+ years of tag release and recapture data, as detailed in Hanselman et al. (2015). 
```{r, echo=FALSE}
movement_sample <- matrix(data=NA, nrow=n.area,ncol=n.area,dimnames=list(c("From EY","From WY","From CG","From WG","From BS","From AI"),c("To EY","To WY","To CG","To WG","To BS","To AI")))

movement_sample[1,] <- c(0.744367,0.076350,0.149227,0.026232,0.002098,0.001726)
movement_sample[2,] <- c(0.137189,0.191575,0.478710,0.152110,0.021954,0.018462)
movement_sample[3,] <- c(0.108443,0.193604,0.486216,0.162973,0.026394,0.022370)
movement_sample[4,] <- c(0.037484,0.120964,0.320461,0.290733,0.122029,0.108328)
movement_sample[5,] <- c(0.005357,0.031088,0.092290,0.215184,0.627622,0.028460)
movement_sample[6,] <- c(0.002495,0.014990,0.045060,0.113111,0.046442,0.777902)
movement_sample
```
  

# Conditioning period validation
The figures and tables below are presented to show the ability of the spatial OM conditioning period to match the current EM historical data and to further describe the methods for setting up the OM. In general, the conditioning period matches very well to the EM. However some differences exist due to movement, the initial conditions specification, and spatial OM parameters which differ from the management EM. Because this isn't a full MSE, alternative states of nature and alternative realities are not the examamined here. 
```{r, echo=FALSE}
dir.temp <- paste0(dir.output,"/Apport.Option_",1) #OM for conditioning period is the same across apportionment options, so pulling conditioning period output from folder 1
N <- readRDS(file.path(dir.temp,"N.rds")) #OM conditioning period N 
B <- readRDS(file.path(dir.temp,"B.rds")) 
ssb <- readRDS(file.path(dir.temp,"ssb.rds"))
temp.catchnumbiom <- readRDS(file.path(dir.temp,"temp.catchnumbiom.rds"))
C.b <- readRDS(file.path(dir.temp,"C.b.rds"))
harvest.b <- readRDS(file.path(dir.temp,"harvest.b.rds"))
cond.rec <- readRDS(file.path(dir.temp,"cond.Recruitment.rds"))
recruits.area <- readRDS(file.path(dir.temp,"recruits.area.rds"))
va <- readRDS(file.path(dir.temp,"va.rds"))
va_surv <- readRDS(file.path(dir.temp,"va_surv.rds"))
```
Abundance in numbers, biomass, and spawning biomass generated from the OM generally matches the Management model EM quite closely (Figures 1-3).   
``` {r, echo=FALSE}
#management N, by year (summed across ages, sexes) for 1960-2018 is:
mgmtN <- c(227.569424,225.133078,214.348775,202.312974,234.635297,228.675439,
           223.024404,233.474335,226.238316,210.835746,197.26262,183.638328,
           162.608407,138.835745,123.192946,118.53197,108.080044,93.414099,
           83.964022,159.561953,166.4444777,157.2009806,180.5002287,183.5209969,
           205.8722927,184.1836206,181.7986075,174.4102706,150.830862,129.4616883,
           113.7451334,121.4683674,104.0961752,111.7859086,99.2854377,89.0569055,
           82.837678,87.163893,77.2629253,96.086156,100.0417057,96.0967192,
           124.029391,113.7307861,110.2138382,99.9701582,95.7489713,89.5424044,
           84.6328623,80.147036,86.599641,79.9309313,77.8211843,67.23660782,
           64.6833935,68.2611382,208.8285434,225.8192621,212.4078021)

#OM conditioning period N, by year (summed across ages, sexes, areas)
simN_sum <- apply(N[,,,,1],2,sum) # sim 1 results only (sims are all identical for conditioning period)
par(mfrow=c(1,1))
plot(mgmtN~mgmt_rep_years, ylim=c(0,250),typ="l",lwd=3,col="red",xlab="Year",ylab="Abundance (millions)")
lines(simN_sum[2:43]~OMyears,typ="l",lwd=3,col="black") 
legend("bottomleft", legend=c("Management EM", "Conditioning OM"),lty=c(1,1),lwd=c(3,3), col=c("red","black"))

```
  
Figure 1: Abundance in numbers (millions of fish, summed over areas) generated from the OM matches the Management model EM.

```{r, echo=FALSE}
#mgmt_rep$Tot_biom #management EM total biomass
simB_sum <- apply(B[,,,,1],2,sum) #OM conditioning period B, by year (summed across ages, sexes, areas), from sim 1
par(mfrow=c(1,1))
plot(mgmt_rep$Tot_biom~mgmt_rep_years, ylim=c(0,650),typ="l",lwd=3,col="red",xlab="Year",ylab="Biomass (kt)")
lines(simB_sum[2:43]~OMyears,typ="l",lwd=3,col="black") 
legend("bottomleft", legend=c("Management EM", "Conditioning OM"),lty=c(1,1),lwd=c(3,3), col=c("red","black"))

```
  
Figure 2: Biomass (kt, summed over areas) generated from the OM compared to the Management model EM.  
  
```{r, echo=FALSE}
#mgmt_rep$SpBiom #mgmt EM ssb
simssb_sum <- apply(ssb[,,,,1],3,sum) #OM conditioning period ssb, summed across ages, sexes, areas
par(mfrow=c(1,1))
plot(mgmt_rep$SpBiom~mgmt_rep_years, ylim=c(0,300),typ="l",lwd=3,col="red",xlab="Year",ylab="Spawning Biomass (kt)")
lines(simssb_sum[2:43]~OMyears,typ="l",lwd=3,col="black") 
legend("bottomleft", legend=c("Management EM", "Conditioning OM"),lty=c(1,1),lwd=c(3,3), col=c("red","black"))

```
  
Figure 3: Spawning biomass (kt, summed over areas) generated from the OM compared to the Management model EM.  

OM catch was designed to match EM observed catch. An F-solving function in the OM takes input catch by gear/fleet, area, and year and estimates the fishing mortality required to take that catch, using OM numbers at age and selectivity. The estimated F rate is then used to calculate abundance for the OM.  
```{r, echo=FALSE}
mgmtCatch <- mgmt_rep$Obs_CatchTrawl + mgmt_rep$Obs_CatchFixedGear #total catch from mgmt EM
read.in.catch <- apply(temp.catchnumbiom,1,sum)
sim_C.b_sum <- apply(C.b[,,,,1],2,sum)
sim_harv_sum <- apply(harvest.b[,,,,,1],2,sum)
#Option 1
#plot(mgmtCatch~mgmt_rep_years, ylim=c(0,55),typ="l",lwd=3,col="red",xlab="Year",ylab="Catch (kt)")
#lines(read.in.catch[2:(length(OMyears)+1)]~OMyears,typ="l",lwd=3,col="black")
#lines(sim_C.b_sum[2:(length(OMyears)+1)]~OMyears,typ="l",lwd=3,col="blue")
#lines(sim_harv_sum[2:(length(OMyears)+1)]~OMyears,typ="l",lwd=3,col="blue")
#legend("topright", legend=c("Management EM Catch", "Conditioning OM Input Catch", "Conditioning OM Est. Catch", "Conditioning OM Est. Harvest"),lty=c(1,1,1,1),lwd=c(3,3,3,3), col=c("red","black","blue","blue"))
#option 2 - without harvest line
plot(mgmtCatch~mgmt_rep_years, ylim=c(0,55),typ="l",lwd=3,col="red",xlab="Year",ylab="Catch (kt)")
lines(read.in.catch[2:(length(OMyears)+1)]~OMyears,typ="l",lwd=3,col="black")
lines(sim_C.b_sum[2:(length(OMyears)+1)]~OMyears,typ="l",lwd=3,col="blue")
legend("topright", legend=c("Management EM Catch", "Conditioning OM Input Catch", "Conditioning OM Est. Catch"),lty=c(1,1,1),lwd=c(3,3,3), col=c("red","black","blue"))
```
  
Figure 4: Catch (kt) for the management EM, the input catch values for the OM, and the estimated OM catch values.  

OM recruitment for the conditioning period was designed to match EM recruitment. Management EM recruitment values (in numbers) for 1977-2018 are input and split into `r n.area` areas based on the proportion of age-2 sablefish in the longline survey in each area, and also split equally between males and females (see equations in appendix).  
``` {r, echo=FALSE}
mgmt_rep_recruitment <- c(122.9618,20.0246,15.45504,16.50548,57.0088,18.69596,18.98642,36.665,21.0668,15.71956,
       17.67248,16.18402,9.21424,7.10778,8.0244,16.61306,9.04232,4.41974,5.29922,86.386,25.42,9.9051,
       42.303,23.9728,43.5138,2.33748,19.53042,18.80922,3.6228,4.52162,6.87626,27.2682,1.286332,23.7892,4.59836,
       5.31364,7.73184,16.88416,2.30162,29.923,16.93562,10.15266,41.4692,6.34222,12.67834,6.05714,10.71728,
       7.79438,8.44232,7.82108,17.84292,5.03906,9.29366,1.01781,7.98824,13.20866,150.343,40.1198,12.4912)
#cond.rec$Recruitment #recruits for the conditioning period - these values are the input to the OM, once split into areas

plot(mgmt_rep_recruitment~mgmt_rep_years,xlim=c(1960,2020),typ="l",lwd=3,col="red",ylim=c(0,175),ylab=c("Recruitment - age 2"),xlab=c("Year"))
lines(cond.rec~OMyears,lty=3,lwd=3,col="black")
legend("topleft", legend=c("Management EM Recruitment", "Conditioning OM Recruitment"),lty=c(1,3),lwd=c(3,3), col=c("red","black"))

```
  
Figure 5: OM and EM recruitment for the conditioning period (in millions of fish) for all management areas summed are identical by design.  

Table 2: These values for age-2 proportions by area from the longline survey are used to split recruitment into spatial areas.   
``` {r, echo=FALSE}
#conditioning recruitment by area
rec.by.area.props <- vector()
rec.by.area.props <- c(0.14,0.07,0.14,0.43,0.14,0.09)
names(rec.by.area.props) <- c("BS","AI","WG","CG","WY","EY/SEO")
rec.by.area.props
```
  

``` {r, echo=FALSE}
sum_c.rec1 <- apply(N[,2:43,1,,1],c(2,3),sum) #recruitment by year and area
sum_c.rec2 <- apply(N[,2:43,1,,1],2,sum) #recruitment by year
plot(sum_c.rec1[,1]~OMyears,typ="l",lwd=4,col="black",ylim=c(0,55),ylab="Recruitment @ age 2 (millions)", xlab="Year",lty=1)
lines(sum_c.rec1[,2]~OMyears,typ="l",lwd=4,col="green",lty=2)
lines(sum_c.rec1[,3]~OMyears,typ="l",lwd=4,col="red",lty=1)
lines(sum_c.rec1[,4]~OMyears,typ="l",lwd=4,col="grey",lty=1)
lines(sum_c.rec1[,5]~OMyears,typ="l",lwd=4,col="orange",lty=3)
lines(sum_c.rec1[,6]~OMyears,typ="l",lwd=4,col="blue",lty=3)
legend("topleft", legend=c("BS", "AI","WG", "CG","WY", "EY/SEO"),lty=c(1,2,1,1,3,3),lwd=c(3,3,3,3,3,3), col=c("black","green","red","grey","orange","blue"))

```
  
Figure 6: The resulting recruitment of age-2 fish to each management area for the conditioning period, after splitting into spatial areas using the proportions in Table 2.  

Recruitment for the forward projecting period is the same across apportionment simulations and does not have a stock recruitment relationship. Using the same suite of recruitment draws across each apportionment method allows for a more similar comparison of results. Recruitment for n.years x n.sims is drawn once (from a multinomial distribution with mu=16.5 and sigma=1) and used for all apportionment methods. Mean recruitment (mu; average log-recruitment) and recruitment standard deviation (sigma) for the multinomial are input from the management EM. Recruitment in each year is divided into OM spatial areas based on the mean proportion of age-2 (recruitment age) sablefish in each area from the longline survey for 1977-2018, as described above.  

```{r, echo=FALSE}
sum.rec.area <- apply(recruits.area,c(1,3),sum)
#mgmt_rep_recruitment
plot(mgmt_rep_recruitment~mgmt_rep_years,xlim=c(1960,2020),typ="l",lwd=3,col="red",ylim=c(0,200),ylab="Recruitment @ age 2 (millions)", xlab="Year")
for(i in 1:n.sims){
lines(sum.rec.area[c(1:43),i]~c(1976:2018),typ="l",lwd=1,col="black")
}
legend("topleft", legend=c("Management EM Recruitment", "Simulated OM Recruitments"),lty=c(1,1),lwd=c(3,1), col=c("red","black"))
```
  
Figure 7: For comparison, the conditioning period recruitment draws for `r n.sims` compared to management EM estimated recruitment is shown here, though note that these values ARE NOT USED in the conditioning period. 

```{r, echo=FALSE}
plot(mgmt_rep_recruitment~mgmt_rep_years,xlim=c(1960,2020),typ="l",lwd=3,col="red",ylab="Recruitment @ age 2 (millions)", xlab="Year")
lines(sum.rec.area[c(1:43),1]~c(1976:2018),typ="l",lwd=1,col="blue")
lines(sum.rec.area[c(1:43),15]~c(1976:2018),typ="l",lwd=1,col="green")
lines(sum.rec.area[c(1:43),33]~c(1976:2018),typ="l",lwd=1,col="black")
lines(sum.rec.area[c(1:43),47]~c(1976:2018),typ="l",lwd=1,col="orange")
```
  
Bonus figure 7b: this shows a few individual simulations of recruitment to better view the individual variability and scale of simulated recruitment.    

## Selectivity in OM  
The following figures show the selectivity at age and for each area used in the OM. These are used for all years of the OM, not just the conditioning period.  

SIDE QUESTION FOR DANA, CHRIS, CURRY, ET AL.: DO WE WANT/NEED TO CHANGE ANY OF THE OM SELECTIVITY VALUES?
 
```{r, echo=FALSE}
#selectivty OM vs Mgmt EM
#by fleet for fishery
#US fixed gear pre IFQ
par(mfrow=c(3,2),mar=c(4,4,2,2))
for(m in 1:n.area){
plot(va[1,m,1,]~ages,typ="l",col="black",lwd=3,ylim=c(0,1),ylab="Selectivity",xlab="Age")
lines(va[1,m,2,]~ages,typ="l",col="black",lwd=3,lty=3)
lines(mgmt_rep$Fishery_sel1Females~ages,typ="l",col="red",lwd=3,lty=1)
lines(mgmt_rep$Fishery_sel1Males~ages,typ="l",col="red",lwd=3,lty=3)
title(paste("Area",m,"Fishery",fish[1]))
}
legend("bottomright", legend=c("Management EM Female", "Management EM Male","Simulated OM Female","Simulated OM Male"),lty=c(1,3,1,3),lwd=c(3,3,3,3), col=c("red","red","black","black"),cex=0.75)

```
  
Figure 8: US fixed gear pre-IFQ selectivity for each area has a logistic form.  US fixed gear pre-IFQ selectivity is sex-specific but does not differ between spatial areas; OM values are the the same as the values estimated from the spatial 'research' EM which is under development and has been reported on to the PT in the past.  [COAUTHORS - DO WE WANT TO CHANGE THESE VALUES FOR FUTURE RUNS? THINK ABOUT THAT WHEN YOU SEE FITS TO SELECTIVITY IN THE FORWARD PROJECTING OUTPUTS]  
  
```{r, echo=FALSE}  
#US fixed gear post IFQ
par(mfrow=c(3,2),mar=c(4,4,2,2))
for(m in 1:n.area){
plot(va[2,m,1,]~ages,typ="l",col="black",lwd=3,ylim=c(0,1),ylab="Selectivity",xlab="Age")
lines(va[2,m,2,]~ages,typ="l",col="black",lwd=3,lty=3)
lines(mgmt_rep$Fishery_sel4_f~ages,typ="l",col="red",lwd=3,lty=1)
lines(mgmt_rep$Fishery_sel4_m~ages,typ="l",col="red",lwd=3,lty=3)
title(paste("Area",m,"Fishery",fish[2]))
} 
legend("bottomright", legend=c("Management EM Female", "Management EM Male","Simulated OM Female","Simulated OM Male"),lty=c(1,3,1,3),lwd=c(3,3,3,3), col=c("red","red","black","black"),cex=0.75)

```  
  
Figure 9: US fixed gear post-IFQ selectivity for each area has a logistic form. The values are sex-specific and there are some spatial differences for some areas. OM values for each area are based on the estimated selectivity values from the spatial 'reseach' EM.  

```{r, echo=FALSE}
#US trawl fish
par(mfrow=c(3,2),mar=c(4,4,2,2))
for(m in 1:n.area){
plot(va[3,m,1,]~ages,typ="l",col="black",lwd=3,ylim=c(0,1),ylab="Selectivity",xlab="Age")
lines(va[3,m,2,]~ages,typ="l",col="black",lwd=3,lty=3)
lines(mgmt_rep$Fishery_sel3~ages,typ="l",col="red",lwd=3,lty=1)
title(paste("Area",m,"Fishery",fish[3]))
} 
legend("topright", legend=c("Management EM Female", "Management EM Male","Simulated OM Female","Simulated OM Male"),lty=c(1,3,1,3),lwd=c(3,3,3,3), col=c("red","red","black","black"),cex=0.75)

```  
  
Figure 10: US trawl fishery selectivity for the OM has a domed shape. The values are sex specific and do not vary spatially. Values are from the 'research' spatial EM.    
```{r, echo=FALSE}  
#US fixed gear foreign
#par(mfrow=c(3,2),mar=c(4,4,2,2))
#for(m in 1:n.area){
#plot(va[4,m,1,]~ages,typ="l",col="black",lwd=3,ylim=c(0,1),ylab="Selectivity",xlab="Age")
#lines(va[4,m,2,]~ages,typ="l",col="black",lwd=3,lty=3)
#lines(mgmt_rep$Fishery_sel2~ages,typ="l",col="red",lwd=3,lty=1)
#title(paste("Area",m,"Fishery",fish[4]))
#}
#legend("bottomright", legend=c("Management EM Female", "Management EM Male","Simulated OM Female","Simulated OM #Male"),lty=c(1,3,1,3),lwd=c(3,3,3,3), col=c("red","red","black","black"),cex=0.75)
 #Figure XX: US fixed gear foreign is only used for the OM as the fishery ended in 1981. [COAUTHORS - I THINK I CAN #JUST REMOVE THIS PART ABOUT FOREIGN FISHERY SELECTIVITY SINCE IT'S NOT VERY RELEVANT OR INFLUENTIAL AND JUST TAKES #UP SPACE - AGREE/DISAGREE?]
``` 
  

```{r, echo=FALSE}  
#US ll survey
par(mfrow=c(1,1),mar=c(4,4,2,2))
plot(va_surv[1,1,]~ages,typ="l",col="black",lwd=3,ylim=c(0,1),ylab="Selectivity",xlab="Age")
lines(va_surv[1,2,]~ages,typ="l",col="black",lwd=3,lty=3)
lines(mgmt_rep$Survey_sel1Female~ages,typ="l",col="red",lwd=3,lty=1)
lines(mgmt_rep$Survey_sel1male~ages,typ="l",col="orange",lwd=3,lty=3)
title(paste("Area","Survey","US LL"))
legend("bottomright", legend=c("Management EM Female", "Management EM Male","Simulated OM Female","Simulated OM Male"),lty=c(1,3,1,3),lwd=c(3,3,3,3), col=c("red","red","black","black"),cex=0.75)
```
  
Figure 11: US longline survey selectivity parameters are not spatial but are sex specific and are based on the spatial 'research' EM values.  

```{r, echo=FALSE}  
#USJP ll coop survey
par(mfrow=c(1,1),mar=c(4,4,2,2))
plot(va_surv[2,1,]~ages,typ="l",col="black",lwd=3,ylim=c(0,1),ylab="Selectivity",xlab="Age")
lines(va_surv[2,2,]~ages,typ="l",col="black",lwd=3,lty=3)
lines(mgmt_rep$Survey_sel2Female~ages,typ="l",col="red",lwd=3,lty=1)
lines(mgmt_rep$Survey_sel2male~ages,typ="l",col="orange",lwd=3,lty=3)
title(paste("Area","Survey", "USJP coop"))
legend("bottomright", legend=c("Management EM Female", "Management EM Male","Simulated OM Female","Simulated OM Male"),lty=c(1,3,1,3),lwd=c(3,3,3,3), col=c("red","red","black","black"),cex=0.75)

```
  
Figure 12: The USJP ll cooperative survey selectivity parameters are not spatial but are sex specific and values are based on the management EM values.  
  
    
## Sampling OM population for abundance indices, age comps  
The EM requires a longline survey abundance index, a fishery CPUE index, and survey and fishery age compositions. For both the conditioning period and the forward projecting period, the OM population is 'sampled' with logistic observation error for the indices of abundance. For each spatial area in the OM, we sample abundance for the survey and biomass for the fishery index, both with 15% sigma for observation error. Spatial areas are summed for each index, resulting in a single fishery and a single survey index.  Fits to indices of abundance are shown in the next section.

Age compositions are sampled from each spatial OM regional abundance using Dirichlet multinomial error and a sample size of 200. Age compositions are combined across spatial errors (weighted by catch/survey abundance in each area) to a single set of survey and a single set of fishery age comps that are not sex specific. 

#EM specifications  
For 2019 onward, the EM is run at every annual step using data 'sampled' from the OM population. As a reminder the order of operations for year y are: OM - Read in previous year's apportioned ABC by area (from the EM), estimate the F required to catch ABC for each area, apply F and M to OM population, move fish between areas, sample the population for fishery and longline survey abundance indices and for longline survey and fixed gear fishery age compositions, build the .dat file and pass it to the EM in ADMB, run the EM and get an estimate of the next year's ABC (then repeat for the next year).

# Forward looping model output

## EM Convergence  
```{r,echo=FALSE}
mgc_val <- 0.01
```
First, we look at the proportion of years within a simulation and apportionment scenario which converged. At present, non-converged models/years/sims ARE NOT removed from the following analyses. For these simulations, a model was considered 'converged' for a given year if the max gradient component was < `r mgc_val`.  
  
Table x. The proportion of sims which converged for each year for each apportionment method are:  
```{r, echo=FALSE}
AM_max_grads <- array(data=NA, dim=c(n.year,n.sims,length(1:n.apports)), dimnames=list(years,sims,apports)) #Apportionment Master (AM) file for analyses
for(b in 1:n.apports){
  dir.temp <- paste0(dir.output,"/Apport.Option_",b)
AM_max_grads[,,b] <- readRDS(file.path(dir.temp,"maxgrads.rds")) 
}
#proportion of years in a sim that converged
#average proportion of years in all sims that converged for each apportionment option
conv_num <- array(data=NA, dim=c(n.year,n.sims,n.apports), dimnames=list(years,sims,apport.names))
#max_grads <- (format(max_grads,scientific=FALSE))
for(b in 1:n.apports){
  for(i in 1:n.sims){
    for(y in forproj.styr:n.year){
      if(abs(AM_max_grads[y,i,b]) < mgc_val) {
        conv_num[y,i,b] <- 1      
      } else {
        conv_num[y,i,b] <- 0      
      }
    }
  }
}
#proportion converged 
#(proportion of sims that converged in year y) for each apportionment type
temp_a <- apply(conv_num[forproj.styr:n.year,,],c(1,3),sum)
temp_a1 <- temp_a/n.sims 
rownames(temp_a1) <- c(2019:(2019+(n.year-44)))
temp_a1
```
  
Table x. The proportion of years which converged for each sims and apportionment method are:  
```{r, echo=FALSE}
#(proportion of years that converged in each sim i)
temp_b <- apply(conv_num[forproj.styr:n.year,,],c(2,3),sum)
temp_b1 <- temp_b/length(forproj.styr:n.year)
temp_b1
```

Finally, the overall proportion of years x sims that converged for each apportionment method are below. Note that for now, all models (converged or not) are included in the following output figures and performance metric calculations.  
Table x.  The proportion of years x sims which converged.  
```{r, echo=FALSE} 
#proportion of sims and years that converged
for(b in 1:n.apports){
temp_c <- sum(temp_b[,b])/(length(forproj.styr:n.year)*n.sims) 
#dimnames(temp_c) <- (apport.names)
print(temp_c)
}
```

## Objective function values  [these are likely just for diagnostics...I don't think we need these in the version that goes to the plan team...]   I also collect and could output the SPR penalty values, but they aren't very interesting or useful.  
The objective function values for each sim and year iteration of the EM were:  
``` {r, echo=FALSE}
#Apportionment Master (AM) file of objective function values
AM_ofv <- array(data=NA, dim=c(n.year,n.sims,length(1:n.apports)),dimnames=list(c(1976:(1976+n.year-1)),sims,apport.names))  
#Apportionment Master (AM) file of SPR penalty values
AM_sprpen <- array(data=NA, dim=c(n.year,n.sims,length(1:n.apports)), dimnames=list(c(1976:(1976+n.year-1)),sims,apport.names))
#read them in:
#for(b in 1:n.apports){
#  dir.temp <- paste0(dir.output,"/Apport.Option_",b)
#AM_ofv[,,b] <- readRDS(file.path(dir.temp,"obj_fun_vals.rds")) 
#AM_sprpen[,,b] <- readRDS(file.path(dir.temp,"spr_penalty.rds")) 
#}
#AM_ofv[44:n.year,,]
#AM_sprpen[44:n.year,,]
```
  
## EM Selectivity  
The next series of figures shows the EM estimated selectivity alongside the OM selectivity for each fishery and survey.  
``` {r,echo=FALSE}
#create arrays for the selectivities across sims
AM_pred.sel.preifq <- array(data=NA,dim=c(n.year,n.age,n.sex,n.sims,length(1:n.apports)),dimnames=list(c(1976:(1976+n.year-1)),ages,sexes,sims,apport.names))
AM_pred.sel.postifq <- array(data=NA,dim=c(n.year,n.age,n.sex,n.sims,length(1:n.apports)),dimnames=list(c(1976:(1976+n.year-1)),ages,sexes,sims,apport.names))
AM_pred.sel.trawl <- array(data=NA,dim=c(n.year,n.age,n.sex,n.sims,length(1:n.apports)),dimnames=list(c(1976:(1976+n.year-1)),ages,sexes,sims,apport.names))
AM_pred.sel.LLsurv <- array(data=NA,dim=c(n.year,n.age,n.sex,n.sims,length(1:n.apports)),dimnames=list(c(1976:(1976+n.year-1)),ages,sexes,sims,apport.names))
#then read them all in
for(b in 1:n.apports){
  dir.temp <- paste0(dir.output,"/Apport.Option_",b)
AM_pred.sel.preifq[,,,,b] <- readRDS(file.path(dir.temp,"EM_pred.sel.preifqfish.rds")) 
AM_pred.sel.postifq[,,,,b] <- readRDS(file.path(dir.temp,"EM_pred.sel.postifqfish.rds")) 
AM_pred.sel.trawl[,,,,b] <- readRDS(file.path(dir.temp,"EM_pred.sel.trawlfish.rds")) 
AM_pred.sel.LLsurv[,,,,b] <- readRDS(file.path(dir.temp,"EM_pred.sel.LLsurv.rds")) 
}
```
  
### Longline fishery Pre-IFQ selectivity
  
```{r, echo=FALSE}
if(n.apports==1){
par(mfrow=c(1,1))
}
if(n.apports==2){
par(mfrow=c(1,2))
}
if(n.apports>3){
par(mfrow=c(2,2))
}
#females
for(b in 1:n.apports){
plot(va[1,1,1,]~ages,typ="l",lwd=4,ylim=c(0,1),main=c(paste0("Apportionment: ",apport.names[b],", Female LL Pre-IFQ")),ylab="Selectivity",xlab="Age",cex.main=0.75)  #OM selectivity
lines(va[1,2,1,]~ages,typ="l",lwd=4)
lines(va[1,3,1,]~ages,typ="l",lwd=4)
lines(va[1,4,1,]~ages,typ="l",lwd=4)
lines(va[1,5,1,]~ages,typ="l",lwd=4)
lines(va[1,6,1,]~ages,typ="l",lwd=4)
for(y in forproj.styr:n.year){
for(i in 1:n.sims){
lines(AM_pred.sel.preifq[y,,1,i,b]~ages,typ="l",lwd=2, col="red")
}}
legend("bottomright",legend=c("EM","OM"),lwd=c(2,4),col=c("red","black"),cex=0.5)
}
#males
for(b in 1:n.apports){
plot(va[1,1,2,]~ages,typ="l",lwd=4,ylim=c(0,1),main=c(paste0("Apportionment: ",apport.names[b],", Male LL Pre-IFQ")),ylab="Selectivity",xlab="Age",cex.main=0.75)  #OM selectivity
lines(va[1,2,2,]~ages,typ="l",lwd=4)
lines(va[1,3,2,]~ages,typ="l",lwd=4)
lines(va[1,4,2,]~ages,typ="l",lwd=4)
lines(va[1,5,2,]~ages,typ="l",lwd=4)
lines(va[1,6,2,]~ages,typ="l",lwd=4)
for(y in forproj.styr:n.year){
for(i in 1:n.sims){
lines(AM_pred.sel.preifq[y,,2,i,b]~ages,typ="l",lwd=2, col="red")
}}
legend("bottomright",legend=c("EM","OM"),lwd=c(2,4),col=c("red","black"),cex=0.5) 
}

```
  
Figure x. EM estimated selectivity for the longline fishery, Pre-IFQ years for each sex and apportionment method. Each red line in a single figure panel represents a different simulation and year. Pre-IFQ selectivity does not differ over spatial areas in the OM.  
  
### Longline fishery Post-IFQ  
```{r, echo=FALSE}
if(n.apports==1){
par(mfrow=c(1,1))
}
if(n.apports==2){
par(mfrow=c(1,2))
}
if(n.apports>3){
par(mfrow=c(2,2))
}
#females
for(b in 1:n.apports){
plot(va[2,1,1,]~ages,typ="l",lwd=4,ylim=c(0,1),main=c(paste0("Apportionment: ",apport.names[b],", Female LL Post-IFQ")),ylab="Selectivity",xlab="Age",cex.main=0.75)  #OM selectivity
lines(va[2,2,1,]~ages,typ="l",lwd=4)
lines(va[2,3,1,]~ages,typ="l",lwd=4)
lines(va[2,4,1,]~ages,typ="l",lwd=4)
lines(va[2,5,1,]~ages,typ="l",lwd=4)
lines(va[2,6,1,]~ages,typ="l",lwd=4)
for(y in forproj.styr:n.year){
for(i in 1:n.sims){
lines(AM_pred.sel.postifq[y,,1,i,b]~ages,typ="l",lwd=2, col="red")
}}
legend("bottomright",legend=c("EM","OM"),lwd=c(2,4),col=c("red","black"),cex=0.5)
}
#males
for(b in 1:n.apports){
plot(va[2,1,2,]~ages,typ="l",lwd=4,ylim=c(0,1),main=c(paste0("Apportionment: ",apport.names[b],", Male LL Post-IFQ")),ylab="Selectivity",xlab="Age",cex.main=0.75)  #OM selectivity
lines(va[2,2,2,]~ages,typ="l",lwd=4)
lines(va[2,3,2,]~ages,typ="l",lwd=4)
lines(va[2,4,2,]~ages,typ="l",lwd=4)
lines(va[2,5,2,]~ages,typ="l",lwd=4)
lines(va[2,6,2,]~ages,typ="l",lwd=4)
for(y in forproj.styr:n.year){
for(i in 1:n.sims){
lines(AM_pred.sel.postifq[y,,2,i,b]~ages,typ="l",lwd=2, col="red")
}}
legend("bottomright",legend=c("EM","OM"),lwd=c(2,4),col=c("red","black"),cex=0.5)
}
```
  
Figure x. EM estimated selectivity for the longline fishery, Post-IFQ years for each sex and apportionment method. Each red line in a single figure panel represents a different simulation and year. Selectivity does differ over some  spatial areas in the OM, but cannot be estimated spatially in the single-area EM.   
  
### Trawl fishery  
```{r, echo=FALSE}
if(n.apports==1){
par(mfrow=c(1,1))
}
if(n.apports==2){
par(mfrow=c(1,2))
}
if(n.apports>3){
par(mfrow=c(2,2))
}
#females
for(b in 1:n.apports){
plot(va[3,1,1,]~ages,typ="l",lwd=4,ylim=c(0,1),main=c(paste0("Apportionment: ",apport.names[b],", Female LL Trawl")),ylab="Selectivity",xlab="Age",cex.main=0.75)  #OM selectivity
lines(va[3,2,1,]~ages,typ="l",lwd=4)
lines(va[3,3,1,]~ages,typ="l",lwd=4)
lines(va[3,4,1,]~ages,typ="l",lwd=4)
lines(va[3,5,1,]~ages,typ="l",lwd=4)
lines(va[3,6,1,]~ages,typ="l",lwd=4)
for(y in forproj.styr:n.year){
for(i in 1:n.sims){
lines(AM_pred.sel.trawl[y,,1,i,b]~ages,typ="l",lwd=2, col="red")
}}
legend("topright",legend=c("EM","OM"),lwd=c(2,4),col=c("red","black"),cex=0.5)
}
#males
for(b in 1:n.apports){
plot(va[3,1,2,]~ages,typ="l",lwd=4,ylim=c(0,1),main=c(paste0("Apportionment: ",apport.names[b],", Male LL Trawl")),ylab="Selectivity",xlab="Age",cex.main=0.75)  #OM selectivity
lines(va[3,2,2,]~ages,typ="l",lwd=4)
lines(va[3,3,2,]~ages,typ="l",lwd=4)
lines(va[3,4,2,]~ages,typ="l",lwd=4)
lines(va[3,5,2,]~ages,typ="l",lwd=4)
lines(va[3,6,2,]~ages,typ="l",lwd=4)
for(y in forproj.styr:n.year){
for(i in 1:n.sims){
lines(AM_pred.sel.trawl[y,,2,i,b]~ages,typ="l",lwd=2, col="red")
}}
legend("topright",legend=c("EM","OM"),lwd=c(2,4),col=c("red","black"),cex=0.5)
}
```
 
Figure x. EM estimated selectivity for the trawl fishery, for each sex and apportionment method. Each red line in a single figure panel represents a different simulation and year. Selectivity does not differ over spatial areas in the OM.   
 
### Longline survey  
```{r, echo=FALSE}
if(n.apports==1){
par(mfrow=c(1,1))
}
if(n.apports==2){
par(mfrow=c(1,2))
}
if(n.apports>3){
par(mfrow=c(2,2))
}
#females
for(b in 1:n.apports){
plot(va_surv[1,1,]~ages,typ="l",lwd=4,ylim=c(0,1),main=c(paste0("Apportionment: ",apport.names[b],", Female LL Survey")),ylab="Selectivity",xlab="Age",cex.main=0.75)  #OM selectivity
for(y in forproj.styr:n.year){
for(i in 1:n.sims){
lines(AM_pred.sel.LLsurv[y,,1,i,b]~ages,typ="l",lwd=2, col="red")
}}
legend("bottomright",legend=c("EM","OM"),lwd=c(2,4),col=c("red","black"),cex=0.5)
}
#males
for(b in 1:n.apports){
plot(va_surv[1,2,]~ages,typ="l",lwd=4,ylim=c(0,1),main=c(paste0("Apportionment: ",apport.names[b],", Male LL Survey")),ylab="Selectivity",xlab="Age",cex.main=0.75)  #OM selectivity
for(y in forproj.styr:n.year){
for(i in 1:n.sims){
lines(AM_pred.sel.LLsurv[y,,2,i,b]~ages,typ="l",lwd=2, col="red")
}}
legend("bottomright",legend=c("EM","OM"),lwd=c(2,4),col=c("red","black"),cex=0.5)
}
```
  
Figure x. EM estimated selectivity for the longline survey, for each sex and apportionment method. Each red line in a single figure panel represents a different simulation and year. Selectivity does not differ over spatial areas in the OM.   

## Catchability  
Catchability for the EM is shown below in a series of boxplots. For each apportionment option (x axis) the box shows the median (thick line inside the box) and the 25th and 75th percentile interquartile range (box lower and upper border) of EM q estimates across all years and sims. The vertical bars represent the largest and smallest values within 1.5 times the interquartile range, and any values outside these ranges are shown as points. The dashed red line is the OM value of catchability.  
```{r, echo=FALSE}
#create matrices to hold q values from EM for all apportionments
AM_EM_q.LLsurv <- array(data=NA,dim=c(n.year,n.sims,length(1:n.apports)),dimnames=list(c(1976:(1976+n.year-1)),sims,apport.names))
AM_EM_q.USJPsurv <- array(data=NA,dim=c(n.year,n.sims,length(1:n.apports)),dimnames=list(c(1976:(1976+n.year-1)),sims,apport.names))
AM_EM_q.preifqfish <- array(data=NA,dim=c(n.year,n.sims,length(1:n.apports)),dimnames=list(c(1976:(1976+n.year-1)),sims,apport.names))
AM_EM_q.postifqfish <- array(data=NA,dim=c(n.year,n.sims,length(1:n.apports)),dimnames=list(c(1976:(1976+n.year-1)),sims,apport.names))
AM_EM_q.forfish <- array(data=NA,dim=c(n.year,n.sims,length(1:n.apports)),dimnames=list(c(1976:(1976+n.year-1)),sims,apport.names))
OM_q_fish <- array(data=NA,dim=c(n.fish,n.area,n.apports),dimnames=list(fish,areas,apport.names))
OM_q_surv <- array(data=NA,dim=c(n.surv,n.area,n.apports),dimnames=list(surv.name,areas,apport.names))

#then read them all in
for(b in 1:n.apports){
dir.temp <- paste0(dir.output,"/Apport.Option_",b)
AM_EM_q.LLsurv[,,b] <- readRDS(file.path(dir.temp,"EM_q.LLsurv.rds")) 
AM_EM_q.USJPsurv[,,b] <- readRDS(file.path(dir.temp,"EM_q.USJPsurv.rds")) 
AM_EM_q.preifqfish[,,b] <- readRDS(file.path(dir.temp,"EM_q.preifqfish.rds")) 
AM_EM_q.postifqfish[,,b] <- readRDS(file.path(dir.temp,"EM_q.postifqfish.rds")) 
AM_EM_q.forfish[,,b] <- readRDS(file.path(dir.temp,"EM_q.forfish.rds"))
OM_q_fish[,,b] <- readRDS(file.path(dir.temp,"q_fish.rds"))
OM_q_surv[,,b] <- readRDS(file.path(dir.temp,"q_surv.rds"))
}

```
  
### Fixed gear fishery, foreign years  
```{r,echo=FALSE}
melted_EMq.forfish <- melt(AM_EM_q.forfish[forproj.styr:n.year,,],na.rm=FALSE,value.name="Catchability")
ggplot(melted_EMq.forfish,aes(x=Var3,y=Catchability)) +
  geom_boxplot() +
  geom_hline(yintercept=OM_q_fish[4,1,1],linetype="solid",color="red",size=2) 
```
   
### Longline fishery Pre-IFQ  
For the boxplots below, the dashed red line is OM q for BS, AI, and WG. The solid red line is OM q for CG, and the dotted line is OM q for WY and EY/SEO.   
  
```{r,echo=FALSE}
melted_EMq.preifq <- melt(AM_EM_q.preifqfish[forproj.styr:n.year,,],na.rm=FALSE,value.name="Catchability")
ggplot(melted_EMq.preifq,aes(x=Var3,y=Catchability)) +
  geom_boxplot() +
  geom_hline(yintercept=OM_q_fish[1,1,1],linetype="dashed",color="red",size=2) +
  geom_hline(yintercept=OM_q_fish[1,2,1],linetype="dashed",color="red",size=2) +
  geom_hline(yintercept=OM_q_fish[1,3,1],linetype="dashed",color="red",size=2) + 
  geom_hline(yintercept=OM_q_fish[1,4,1],linetype="solid",color="red",size=2) + 
  geom_hline(yintercept=OM_q_fish[1,5,1],linetype="dotted",color="red",size=2) +
  geom_hline(yintercept=OM_q_fish[1,6,1],linetype="dotted",color="red",size=2) +
  coord_cartesian(ylim=c(0,20))
```
   
### Longline fishery Post-IFQ  
For the boxplots below, the dashed red line is OM q for BS, AI, and WG. The solid red line is OM q for CG, and the dotted line is OM q for WY and EY/SEO.    
```{r,echo=FALSE}
melted_EMq.postifq <- melt(AM_EM_q.postifqfish[forproj.styr:n.year,,],na.rm=FALSE,value.name="Catchability")
ggplot(melted_EMq.postifq,aes(x=Var3,y=Catchability)) +
  geom_boxplot() +
  geom_hline(yintercept=OM_q_fish[2,1,1],linetype="dashed",color="red",size=2) +
  geom_hline(yintercept=OM_q_fish[2,2,1],linetype="dashed",color="red",size=2) +
  geom_hline(yintercept=OM_q_fish[2,3,1],linetype="dashed",color="red",size=2) + 
  geom_hline(yintercept=OM_q_fish[2,4,1],linetype="solid",color="red",size=2) + 
  geom_hline(yintercept=OM_q_fish[2,5,1],linetype="dotted",color="red",size=2) +
  geom_hline(yintercept=OM_q_fish[2,6,1],linetype="dotted",color="red",size=2) 
```
   
### Longline survey (US years)     
```{r,echo=FALSE}
melted_EMq.LLsurv <- melt(AM_EM_q.LLsurv[forproj.styr:n.year,,],na.rm=FALSE,value.name="Catchability")
ggplot(melted_EMq.LLsurv,aes(x=Var3,y=Catchability)) +
  geom_boxplot() +
  geom_hline(yintercept=OM_q_surv[1,1,1],linetype="dashed",color="red",size=3)

```
    
### Longline survey (USJP years)
```{r,echo=FALSE}
melted_EMq.USJPsurv <- melt(AM_EM_q.USJPsurv[forproj.styr:n.year,,],na.rm=FALSE,value.name="Catchability")
ggplot(melted_EMq.USJPsurv,aes(x=Var3,y=Catchability)) +
  geom_boxplot() +
  geom_hline(yintercept=OM_q_surv[2,1,1],linetype="dashed",color="red",size=3)

```
   

## Indices  
``` {r, echo=FALSE}
#create arrays to hold indices
AM_EM_pred.srvRPN <- array(data=NA,dim=c(n.year,n.year,n.sims,length(1:n.apports)),dimnames=list(years,years,sims,apport.names))
AM_EM_pred.fishRPW <- array(data=NA,dim=c(n.year,n.year,n.sims,length(1:n.apports)),dimnames=list(years,years,sims,apport.names))
OM.Surv.RPN <- array(data=NA,dim=c(n.year,n.sims,length(1:n.apports)),dimnames=list(years,sims,apport.names))
OM.Fish.RPW <- array(data=NA,dim=c(n.year,n.sims,length(1:n.apports)),dimnames=list(years,sims,apport.names))
#read in the index predictions from the EM and OM
for(b in 1:n.apports){
dir.temp <- paste0(dir.output,"/Apport.Option_",b)
AM_EM_pred.srvRPN[,,,b] <- readRDS(file.path(dir.temp,"EM_pred.srvRPN.rds")) 
AM_EM_pred.fishRPW[,,,b] <- readRDS(file.path(dir.temp,"EM_pred.fishRPW.rds")) 
OM.Surv.RPN[,,b] <- readRDS(file.path(dir.temp,"OM_Surv.RPN.rds")) 
OM.Fish.RPW[,,b] <- readRDS(file.path(dir.temp,"OM_Fish.RPW.rds")) 
}
```
 
### US longline survey index (RPN)   
The OM ('true') and EM fits to the longline survey abundance index are shown below for each apportionment method. While this is interesting, it's probably not the best way to show things. Keep or discard this for the PT?   
``` {r, echo=FALSE}
#melted_EM_pred.srvRPN <- melt(AM_EM_pred.srvRPN,na.rm=TRUE,value.name="EM.RPN") 
#Plot EM and OM RPN terminal year only, across sims
if(n.apports==1){
par(mfrow=c(1,1))
}
if(n.apports==2){
par(mfrow=c(1,2))
}
if(n.apports>3){
par(mfrow=c(2,2))
}
for(b in 1:n.apports){
plot(AM_EM_pred.srvRPN[n.year,15:n.year,1,b]~c(15:n.year),typ="l",ylim=c(0,2000),ylab="Survey RPN",xlab="Year",col="red",main=apport.names[b])
#for(y in forproj.styr:n.year){
  for(i in 1:n.sims){
    lines(AM_EM_pred.srvRPN[n.year,15:n.year,i,b]~c(15:n.year),typ="l",col="red")
  }
for(i in 1:n.sims){
  lines(OM.Surv.RPN[15:n.year,i,b]~c(15:n.year),typ="l",col="black")
}
  legend("topleft",legend=c("EM","OM"),lwd=c(2,4),col=c("red","black"),cex=0.5)
}

```
  

``` {r, echo=FALSE}
#OM-EM Residuals - these are the residuals between estimated EM and 'true' EM survey index for each apportionment method, using all years and sims (not just the terminal year EM run index estimates)
#resid.RPN <- array(data=NA, dim=c(n.year,n.year,n.sims,n.apports),dimnames=list(years,years,sims,apport.names))
#for(b in 1:n.apports) {
#for (y in 1:n.year) {
#for(k in 1:n.year) {
# for(i in 1:n.sims) {
#resid.RPN[y,k,i,b] <- OM.Surv.RPN[y,i,b] - AM_EM_pred.srvRPN[y,k,i,b]
#}}}}
#melt_resid.rpn <- melt(resid.RPN,na.rm=TRUE,value.name="resid")
#ggplot(melt_resid.rpn,aes(x=Var4,y=resid))+
#geom_boxplot()

```
  
These boxplots are skowing the terminal year EM run residuals from OM, for all sims.  Do these make sense??  Are they a good way to show how well (not well) the EM is fitting the OM for the longline survey?
``` {r, echo=FALSE}
resid.RPN2 <- array(data=NA, dim=c(n.year,n.sims,n.apports),dimnames=list(years,sims,apport.names))
for(b in 1:n.apports) {
#for (y in 1:n.year) {
  for(k in 1:n.year) {
  for(i in 1:n.sims) {
    resid.RPN2[k,i,b] <- OM.Surv.RPN[k,i,b] - AM_EM_pred.srvRPN[n.year,k,i,b]
  }}}#}
#resid.RPN[forproj.styr:n.year,15:n.year,,]
melt_resid.rpn2 <- melt(resid.RPN2,na.rm=TRUE,value.name="resid")
ggplot(melt_resid.rpn2,aes(x=Var3,y=resid))+
  geom_boxplot()

```
  
### US longline fishery index (RPW)  
The OM ('true') and EM fits to the longline fishery abundance index are shown below for each apportionment method. Why doesn't the OM want to get as high(for samples) as the EM? Recruitment??
``` {r, echo=FALSE}
#melted_EM_pred.srvRPN <- melt(AM_EM_pred.srvRPN,na.rm=TRUE,value.name="EM.RPN") 
#Plot EM and OM RPN terminal year only, across sims
if(n.apports==1){
par(mfrow=c(1,1))
}
if(n.apports==2){
par(mfrow=c(1,2))
}
if(n.apports>3){
par(mfrow=c(2,2))
}
for(b in 1:n.apports){
plot(AM_EM_pred.fishRPW[n.year,15:n.year,1,b]~c(15:n.year),typ="l",ylim=c(500,2200),ylab="Fishery RPW",xlab="Year",col="red",main=apport.names[b])
#for(y in forproj.styr:n.year){
  for(i in 1:n.sims){
    lines(AM_EM_pred.fishRPW[n.year,15:n.year,i,b]~c(15:n.year),typ="l",col="red")
  }
for(i in 1:n.sims){
  lines(OM.Fish.RPW[15:n.year,i,b]~c(15:n.year),typ="l",col="black")
}
  legend("topleft",legend=c("EM","OM"),lwd=c(2,4),col=c("red","black"),cex=0.5)
}

```
  
These boxplots are skowing the terminal year EM run residuals from OM, for all sims.  Do these make sense??  Are they a good way to show how well (not well) the EM is fitting the OM for the longline survey? 
``` {r, echo=FALSE}
resid.RPW2 <- array(data=NA, dim=c(n.year,n.sims,n.apports),dimnames=list(years,sims,apport.names))
for(b in 1:n.apports) {
#for (y in 1:n.year) {
  for(k in 1:n.year) {
  for(i in 1:n.sims) {
    resid.RPW2[k,i,b] <- OM.Fish.RPW[k,i,b] - AM_EM_pred.fishRPW[n.year,k,i,b]
  }}}#}
#resid.RPN[forproj.styr:n.year,15:n.year,,]
melt_resid.rpw2 <- melt(resid.RPW2,na.rm=TRUE,value.name="resid")
ggplot(melt_resid.rpw2,aes(x=Var3,y=resid))+
  geom_boxplot()

```
  
## Recruitment  
``` {r,echo=FALSE}
#create arrays to hold indices
AM_EM_predrec <- array(data=NA,dim=c(n.year,n.year,n.sims,length(1:n.apports)),dimnames=list(years,years,sims,apport.names))
OM.predrec <- array(data=NA,dim=c(n.year,n.area,n.sims,length(1:n.apports)),dimnames=list(years,areas,sims,apport.names))
OM_N <- array(data=NA,dim=c(n.sex,n.year,n.age,n.area,n.sims,length(1:n.apports)),dimnames=list(sexes,years,ages,areas,sims,apport.names))
#read in the index predictions from the EM and OM
for(b in 1:n.apports){
dir.temp <- paste0(dir.output,"/Apport.Option_",b)
AM_EM_predrec[,,,b] <- readRDS(file.path(dir.temp,"EM_predrec.rds")) 
OM.predrec[,,,b] <- readRDS(file.path(dir.temp,"recruits.area.rds")) 
OM_N[,,,,,b] <- readRDS(file.path(dir.temp,"N.rds"))
}
```
The min and max OM recruitment values (over all sims and years) are:  
Min - `r min(sum_OM.predrec)`   
Max - `r max(sum_OM.predrec)`  
  
The min and max EM recruitment values (over all sims and years) are:  
Min - `r min(AM_EM_predrec,na.rm=TRUE)`  
Max - `r max(AM_EM_predrec,na.rm=TRUE)`  
      
``` {r, echo=FALSE}
#First look at all OM and EM recruitment draws by apportionment scenario:
sum_OM.predrec <- apply(OM.predrec,c(1,3,4),sum) #sum OM predicted recruitment across areas
#if(n.apports==1){
#par(mfrow=c(1,1))
#}
#if(n.apports==2){
#par(mfrow=c(1,2))
#}
#if(n.apports>3){
#par(mfrow=c(2,2))
#}
#for(b in 1:n.apports){
#plot(AM_EM_predrec[n.year,,1,b]~years,col="red",lwd=1,typ="l", ylab="Predicted Recruitment (millions)",xlab="Year",main=apport.names[b])
#  for(i in 1:n.sims){
#  lines(AM_EM_predrec[n.year,,i,b]~years,col="red",lwd=1,typ="l")
#    lines(sum_OM.predrec[,i,b]~years,col="black",lwd=1,typ="l")
#  }
#  legend("topleft",legend=c("EM","OM"),lwd=c(1,1),col=c("red","black"),cex=0.5)
#  }
```
  
Recall that OM recruitment  (black line) is the same across apportionment methods. These are the median EM (red lines) and OM recruitment values, across all sims and years, that are used for each apportionment method. Individual EM medians for an apportionment method are not labeled.  
``` {r, echo=FALSE}
EM_recmed <- apply(AM_EM_predrec[n.year,,,],c(1,3),median)
OM_recmed <- apply(sum_OM.predrec,c(1,3),median)
#min(sum_OM.predrec)
#max(sum_OM.predrec)
#min(AM_EM_predrec,na.rm=TRUE)
#max(AM_EM_predrec,na.rm=TRUE)
#if(n.apports==1){
par(mfrow=c(1,1))
#}
#for(b in 1:n.apports){
plot(OM_recmed[,1]~years,col="black",lwd=3,typ="l",main="Median recruitment",ylab="Recruitment (millions)",xlab="Year",ylim=c(0,15),xlim=c(44,n.year))
lines(EM_recmed[,1]~years,col="red",lwd=1,typ="l")
lines(EM_recmed[,2]~years,col="red",lwd=1,typ="l")
lines(EM_recmed[,3]~years,col="red",lwd=1,typ="l")
lines(EM_recmed[,4]~years,col="red",lwd=1,typ="l")
lines(EM_recmed[,5]~years,col="red",lwd=1,typ="l")
lines(EM_recmed[,6]~years,col="red",lwd=1,typ="l")
legend("topleft",legend=c("EM","OM"),lwd=c(1,1),col=c("red","black"),cex=0.5)
#}
```
  

Then look at the mean EM and mean OM recruitment draws by apport scenario. There is something very wrong with these EM mean values (right now).  
``` {r, echo=FALSE}
#if(n.apports==1){
par(mfrow=c(1,1))
#}
EM_recmean <- apply(AM_EM_predrec[n.year,,,],c(1,3),mean)
OM_recmean <- apply(sum_OM.predrec,c(1,3),mean)
#for(b in 1:n.apports){
plot(EM_recmean[,1]~years,col="red",lwd=1,typ="l",main="Mean recruitment",ylab="Recruitment (millions)",xlab="Year",xlim=c(44,n.year),ylim=c(0,100))
lines(EM_recmean[,2]~years,col="red",lwd=1,typ="l")
lines(EM_recmean[,3]~years,col="red",lwd=1,typ="l")
lines(EM_recmean[,4]~years,col="red",lwd=1,typ="l")
lines(EM_recmean[,5]~years,col="red",lwd=1,typ="l")
lines(EM_recmean[,6]~years,col="red",lwd=1,typ="l")
lines(OM_recmean[,1]~years,col="black",lwd=3,typ="l")
legend("topleft",legend=c("EM","OM"),lwd=c(1,1),col=c("red","black"),cex=0.5)
#}
```
  
Then look at mean EM recruitment, mean OM recruitment, and OM N at age 2.
Why is the EM estimating such high recruitments in the projection years (years 44+) when it doesn't seem to be coming from the OM?  What would be driving that?  Look at residuals next.
``` {r, echo=FALSE}
sum_OM_N <- apply(OM_N[,,1,,,],c(2,4,5),sum) #N at age 2, summed over areas
if(n.apports==1){
par(mfrow=c(1,1))
}
if(n.apports==2){
par(mfrow=c(1,2))
}
if(n.apports>3){
par(mfrow=c(2,2))
}
#par(mfrow=c(1,1))
i=1
for(b in 1:n.apports){
plot(AM_EM_predrec[n.year,,1,b]~years,col="red",lwd=1,typ="l", ylab="Predicted Recruitment (millions)",xlab="Year",main=apport.names[b],xlim=c(44,n.year))
  for(i in 1:n.sims){
  lines(AM_EM_predrec[n.year,,i,b]~years,col="red",lwd=3,typ="l")
  lines(sum_OM.predrec[forproj.styr:n.year,i,b]~c(forproj.styr:n.year),col="black",lwd=5,lty=1)
  lines(sum_OM_N[forproj.styr:n.year,i,b]~c(forproj.styr:n.year), col="green",lwd=3,lty=3)
  }
  legend("topleft",legend=c("EM pred rec","OM rec","OM N at age 2"),lwd=c(3,3,3),col=c("red","black","green"),cex=0.5)
  }
```

Then look at EM-OM residuals  
``` {r, echo=FALSE}
resid.rec2 <- array(data=NA, dim=c(n.year,n.sims,n.apports),dimnames=list(years,sims,apport.names))
for(b in 1:n.apports) {
#for (y in 1:n.year) {
  for(k in 1:n.year) {
  for(i in 1:n.sims) {
    resid.rec2[k,i,b] <- sum_OM_N[k,i,b] - AM_EM_predrec[n.year,k,i,b]
  }}}#}
#resid.RPN[forproj.styr:n.year,15:n.year,,]
melt_resid.rec2 <- melt(resid.rec2,na.rm=TRUE,value.name="resid")
ggplot(melt_resid.rec2,aes(x=Var3,y=resid))+
  geom_boxplot()
```
  
What are other ways of looking at recruitment that might be interesting?
  

## SSB time series  
``` {r, echo=FALSE}
#create arrays for the selectivities across sims
AM_EM_spbiom <- array(data=NA,dim=c(n.year,n.year,n.sims,n.apports),dimnames=list(years,years,sims,apport.names))
OM_ssb <- array(data=NA,dim=c(n.sex,n.age,n.year,n.area,n.sims,length(1:n.apports)),dimnames=list(sexes,ages,years,areas,sims,apport.names))
#then read them all in
for(b in 1:n.apports){
  dir.temp <- paste0(dir.output,"/Apport.Option_",b)
AM_EM_spbiom[,,,b] <- readRDS(file.path(dir.temp,"EM_spbiom.rds")) 
OM_ssb[,,,,,b] <- readRDS(file.path(dir.temp,"ssb.rds")) 
}
```
  
Plot OM spawning biomass vs EM spawning biomass (for all the terminal sim years and sims), for each apportionment method  
``` {r, echo=FALSE}
sum_OM_ssb <- apply(OM_ssb,c(3,5,6),sum)
if(n.apports==1){
par(mfrow=c(1,1))
}
if(n.apports==2){
par(mfrow=c(1,2))
}
if(n.apports>3){
par(mfrow=c(2,2))
}
for(b in 1:n.apports){
plot(sum_OM_ssb[,1,b]~years,col="black",lwd=1,typ="l",ylim=c(0,300),ylab=c("SSB(kt)"),xlab=c("Year"),main=apport.names[b])
for(i in 1:n.sims){
lines(AM_EM_spbiom[n.year,,i,b]~years,col="red",lwd=1,typ="l")
legend("topright",legend=c("EM SSB","OM SSB"),lwd=c(3,3),col=c("red","black"),cex=0.5)
}}
```

SSB residuals 
Two ways.  
```{r,echo=FALSE}
resid.ssb2 <- array(data=NA, dim=c(n.year,n.sims,n.apports),dimnames=list(years,sims,apport.names))
for(b in 1:n.apports) {
#for (y in 1:n.year) {
  for(k in 1:n.year) {
  for(i in 1:n.sims) {
    resid.ssb2[k,i,b] <- sum_OM_ssb[k,i,b] - AM_EM_spbiom[n.year,k,i,b]
  }}}#}
#resid.RPN[forproj.styr:n.year,15:n.year,,]
melt_resid.ssb2 <- melt(resid.ssb2,na.rm=TRUE,value.name="resid")
names(melt_resid.ssb2) <- c("Year","Sim","Apportionment","Resid")
ggplot(melt_resid.ssb2,aes(x=Apportionment,y=Resid))+
  geom_boxplot()

melt_resid.ssb2 %>% 
  ggplot(aes(x=factor(Year),y=Resid,fill=Apportionment)) + 
           geom_boxplot()

```

  
# Performance metrics
As you read the things below, I could use help thinking about ways to combine a suite of interesting (relevant) performance metrics in a table or (maybe) figure that would be a single source of info for comparison. Which of the items below (or that need to be added) would be included?  
```{r,echo=FALSE}
#create arrays for the apportionments
AM_EM_abc <- array(data=NA,dim=c(n.year,n.fish,n.area,n.sims,n.apports),dimnames=list(years,fish,areas,sims,apport.names))
#then read them all in
for(b in 1:n.apports){
  dir.temp <- paste0(dir.output,"/Apport.Option_",b)
AM_EM_abc[,,,,b] <- readRDS(file.path(dir.temp,"apportioned_C.rds")) 
}
```

The overall mean and median (combines: areas, gears, years, sims) for 2019-`r 1976+n.year-1`.  
``` {r,echo=FALSE}
abc_allmean <- apply(AM_EM_abc[44:n.year,,,,],5,mean)
abc_allmed <- apply(AM_EM_abc[44:n.year,,,,],5,median)
abc_allmean
abc_allmed

allmean_sd <- vector()
allmean_uci <- vector()
allmean_lci <- vector()
for(b in 1:n.apports){
allmean_sd[b] <- sd(AM_EM_abc[44:n.year,,,,b])
allmean_uci[b] <- abc_allmean[b] + (1.92*allmean_sd[b])
allmean_lci[b] <- abc_allmean[b] - (1.92*allmean_sd[b])
}

#make a matrix of means, medians, uci, lci
all_abc <- matrix(data=NA,nrow=n.apports,ncol=4)
colnames(all_abc) <- c("Mean","Median","UCI","LCI")
rownames(all_abc) <- c(apport.names)
for(b in 1:n.apports){
all_abc[b,1] <- abc_allmean[b]
all_abc[b,2] <- abc_allmed[b]
all_abc[b,3] <- allmean_uci[b]
all_abc[b,4] <- allmean_lci[b]
}

melted_ABC <- melt(AM_EM_abc[44:n.year,,,,], value.name="ABC")
names(melted_ABC) <- c("Year","Fishery","Area","Sim","Apportionment.Method","ABC")
melted_ABC %>% 
ggplot(aes(x=factor(Apportionment.Method),y=ABC)) +#,fill=Apportionment)) + 
           geom_boxplot()

```
  
  
Median and mean apportioned ABC by area and year (combines: gears, sims) for 2019-`r 1976+n.year-1`.  
```{r,echo=FALSE}
#set up objects to hold secondary products
mean_ABC <- array(data=NA,dim=c(length(forproj.styr:n.year),n.area,n.apports),dimnames=list(years[forproj.styr:n.year],areas,apport.names))
median_ABC <- array(data=NA,dim=c(length(forproj.styr:n.year),n.area,n.apports),dimnames=list(years[forproj.styr:n.year],areas,apport.names))
meanABC_uci <- array(data=NA,dim=c(length(forproj.styr:n.year),n.area,n.apports),dimnames=list(years[forproj.styr:n.year],areas,apport.names))
meanABC_lci <- array(data=NA,dim=c(length(forproj.styr:n.year),n.area,n.apports),dimnames=list(years[forproj.styr:n.year],areas,apport.names))
#medianABC_uci <- array(data=NA,dim=c(n.year,n.area,n.apports),dimnames=list(years,areas,apport.names))
#medianABC_lci <- array(data=NA,dim=c(n.year,n.area,n.apports),dimnames=list(years,areas,apport.names))
sd_1 <- array(data=NA,dim=c(length(forproj.styr:n.year),n.area,n.apports),dimnames=list(years[forproj.styr:n.year],areas,apport.names))
tempsd <- array(data=NA,dim=c(length(forproj.styr:n.year),n.area,n.sims,n.apports),dimnames=list(years[forproj.styr:n.year],areas,sims,apport.names))
#calculate things
mean_ABC <- apply(AM_EM_abc[forproj.styr:n.year,,,,],c(1,3,5),mean)
median_ABC <- apply(AM_EM_abc[forproj.styr:n.year,,,,],c(1,3,5),median)
tempsd <-apply(AM_EM_abc[forproj.styr:n.year,,,,],c(1,3,4,5),sum)
#calc sd 
for(y in 1:length(forproj.styr:n.year)){
  for(m in 1:n.area) {
    for(b in 1:n.apports){
      sd_1[y,m,b] <- sd(tempsd[y,m,,b])
    }}}
#then fill in uci and lci 
for(y in 1:length(forproj.styr:n.year)){
  for(m in 1:n.area) {
    for(b in 1:n.apports){
meanABC_lci[y,m,b] <- mean_ABC[y,m,b] - (1.96*sd_1[y,m,b])
meanABC_uci[y,m,b] <- mean_ABC[y,m,b] + (1.96*sd_1[y,m,b])
    }}}  
#then plot
par(mfrow=c(3,2))
for(b in 1:n.apports){
  for(m in 1:n.area){
plot(mean_ABC[,m,b]~years[forproj.styr:n.year],typ="l",col="black",lwd=3,ylim=c(0,6),ylab=c("ABC (kt)"), xlab=c("Sim year"),main=paste(c(apport.names[b], "Area", areas[m])))
lines(median_ABC[,m,b]~years[forproj.styr:n.year],typ="l",col="red",lwd=3)
lines(meanABC_uci[,m,b]~years[forproj.styr:n.year],lty=3,col="grey",lwd=1)
lines(meanABC_lci[,m,b]~years[forproj.styr:n.year],lty=3,col="grey",lwd=1)
legend("topright",legend=c("Mean ABC","Median ABC","Upper & Lower ~95% CI"),lwd=c(3,3),col=c("black","red","grey","grey"),cex=0.5)
}}
``` 

Median and mean apportioned ABC by area, gear, and year (combines: sims) for 2019-`r 1976+n.year-1`.  
``` {r,echo=FALSE}
#set up objects to hold secondary products
mean_ABC_gear <- array(data=NA,dim=c(length(forproj.styr:n.year),n.fish,n.area,n.apports),dimnames=list(years[forproj.styr:n.year],fish, areas,apport.names))
median_ABC_gear <- array(data=NA,dim=c(length(forproj.styr:n.year),n.fish,n.area,n.apports),dimnames=list(years[forproj.styr:n.year],fish,areas,apport.names))
meanABC_uci_gear <- array(data=NA,dim=c(length(forproj.styr:n.year),n.fish,n.area,n.apports),dimnames=list(years[forproj.styr:n.year],fish,areas,apport.names))
meanABC_lci_gear <- array(data=NA,dim=c(length(forproj.styr:n.year),n.fish,n.area,n.apports),dimnames=list(years[forproj.styr:n.year],fish,areas,apport.names))
sd_2 <- array(data=NA,dim=c(length(forproj.styr:n.year),n.fish,n.area,n.apports),dimnames=list(years[forproj.styr:n.year],fish,areas,apport.names))
#calculate things
mean_ABC_gear <- apply(AM_EM_abc[forproj.styr:n.year,,,,],c(1,2,3,5),mean)
median_ABC_gear <- apply(AM_EM_abc[forproj.styr:n.year,,,,],c(1,2,3,5),median)

#calc sd 
for(y in 1:length(forproj.styr:n.year)){
  for(f in 1:n.fish){
    for(m in 1:n.area) {
      for(b in 1:n.apports){
sd_2[y,f,m,b] <- sd(AM_EM_abc[y,f,m,,b])
      }}}}
#then fill in uci and lci 
for(y in 1:length(forproj.styr:n.year)){
  for(f in 1:n.fish){
    for(m in 1:n.area) {
      for(b in 1:n.apports){
meanABC_lci_gear[y,f,m,b] <- mean_ABC_gear[y,f,m,b] - (1.96*sd_2[y,f,m,b])
meanABC_uci_gear[y,f,m,b] <- mean_ABC_gear[y,f,m,b] + (1.96*sd_2[y,f,m,b])
      }}}} 
#then plot
par(mfrow=c(3,2))
for(b in 1:n.apports){
  for(m in 1:n.area){
plot(mean_ABC_gear[,2,m,b]~years[forproj.styr:n.year],typ="l",col="black",lwd=3,ylim=c(0,10),ylab=c("ABC (kt)"), xlab=c("Sim year"),main=paste(c(apport.names[b], "Area", areas[m])))
  lines(mean_ABC_gear[,3,m,b]~years[forproj.styr:n.year],typ="l",col="blue",lwd=3)
  lines(median_ABC_gear[,2,m,b]~years[forproj.styr:n.year],typ="l",col="red",lwd=3)
  lines(median_ABC_gear[,3,m,b]~years[forproj.styr:n.year],lty=3,col="red",lwd=3)
  lines(meanABC_uci_gear[,2,m,b]~years[forproj.styr:n.year],lty=3,col="grey",lwd=1)
  lines(meanABC_lci_gear[,2,m,b]~years[forproj.styr:n.year],lty=3,col="grey",lwd=1)
  lines(meanABC_uci_gear[,3,m,b]~years[forproj.styr:n.year],lty=3,col="grey",lwd=1)
  lines(meanABC_lci_gear[,3,m,b]~years[forproj.styr:n.year],lty=3,col="grey",lwd=1)
legend("topright",legend=c("Mean ABC Fixed Gear","Mean ABC Trawl Gear","Median ABC Fixed Gear","Median ABC Trawl Gear","Upper & Lower ~95% CI"),lwd=c(3,3,3,3,1,1),col=c("black","blue","red","red","grey","grey"),lty=c(1,1,1,3,1,1,1,1),cex=0.5)
}}
```

Median and mean apportioned ABC by year (combines: areas, gears, sims) for 2019-`r 1976+n.year-1`.  
``` {r,echo=FALSE}
#set up objects to hold secondary products
mean_ABC_allA <- matrix(data=NA,nrow=c(length(forproj.styr:n.year)),ncol=c(n.apports),dimnames=list(years[forproj.styr:n.year],apport.names))
median_ABC_allA <- matrix(data=NA,nrow=c(length(forproj.styr:n.year)),ncol=c(n.apports),dimnames=list(years[forproj.styr:n.year],apport.names))
meanABC_uci_allA <- matrix(data=NA,nrow=c(length(forproj.styr:n.year)),ncol=c(n.apports),dimnames=list(years[forproj.styr:n.year],apport.names))
meanABC_lci_allA <- matrix(data=NA,nrow=c(length(forproj.styr:n.year)),ncol=c(n.apports),dimnames=list(years[forproj.styr:n.year],apport.names))
medianABC_uci_allA <- matrix(data=NA,nrow=c(length(forproj.styr:n.year)),ncol=c(n.apports),dimnames=list(years[forproj.styr:n.year],apport.names))
medianABC_lci_allA <- matrix(data=NA,nrow=c(length(forproj.styr:n.year)),ncol=c(n.apports),dimnames=list(years[forproj.styr:n.year],apport.names))
sd_3 <- matrix(data=NA,nrow=c(length(forproj.styr:n.year)),ncol=c(n.apports),dimnames=list(years[forproj.styr:n.year],apport.names))

#calculate things
mean_ABC_allA <- apply(AM_EM_abc[forproj.styr:n.year,,,,],c(1,5),mean)
median_ABC_allA <- apply(AM_EM_abc[forproj.styr:n.year,,,,],c(1,5),median)
tempsd <-apply(AM_EM_abc[forproj.styr:n.year,,,,],c(1,4,5),sum)

#calc sd 
for(y in 1:length(forproj.styr:n.year)){
  for(b in 1:n.apports){
sd_3[y,b] <- sd(tempsd[y,,b])
  }}
#then fill in uci and lci 
for(y in 1:length(forproj.styr:n.year)){
  for(b in 1:n.apports){
meanABC_lci_allA[y,b] <- meanABC_uci_allA[y,b] - (1.96*sd_3[y,b])
meanABC_uci_allA[y,b] <- meanABC_uci_allA[y,b] + (1.96*sd_3[y,b])
  }} 
#then plot
par(mfrow=c(3,2))
for(b in 1:n.apports){
  for(m in 1:n.area){
plot(mean_ABC_allA[,b]~years[forproj.styr:n.year],typ="l",col="black",lwd=3,ylim=c(0,10),ylab=c("ABC (kt)"), xlab=c("Sim year"),main=paste(c(apport.names[b], "Area", areas[m])))
  lines(median_ABC_allA[,b]~years[forproj.styr:n.year],typ="l",col="red",lwd=3)
  lines(meanABC_uci_allA[,b]~years[forproj.styr:n.year],lty=3,col="grey",lwd=1)
  lines(meanABC_lci_allA[,b]~years[forproj.styr:n.year],lty=3,col="grey",lwd=1)
legend("topright",legend=c("Mean ABC","Median ABC","Upper & Lower ~95% CI"),lwd=c(3,3,1),col=c("black","red","grey"),cex=0.5)
}}
```

Median and mean apportioned ABC by gear (combines: areas, sims) for 2019-`r 1976+n.year-1`.
``` {r,echo=FALSE}
mean_ABC_allgear <- array(data=NA,dim=c(length(forproj.styr:n.year),n.fish,n.apports),dimnames=list(years[forproj.styr:n.year],fish,apport.names))
median_ABC_allgear <- array(data=NA,dim=c(length(forproj.styr:n.year),n.fish,n.apports),dimnames=list(years[forproj.styr:n.year],fish,apport.names))
meanABC_uci_allgear <- array(data=NA,dim=c(length(forproj.styr:n.year),n.fish,n.apports),dimnames=list(years[forproj.styr:n.year],fish,apport.names))
meanABC_lci_allgear <- array(data=NA,dim=c(length(forproj.styr:n.year),n.fish,n.apports),dimnames=list(years[forproj.styr:n.year],fish,apport.names))
medianABC_uci_allgear <- array(data=NA,dim=c(length(forproj.styr:n.year),n.fish,n.apports),dimnames=list(years[forproj.styr:n.year],fish,apport.names))
medianABC_lci_allgear <- array(data=NA,dim=c(length(forproj.styr:n.year),n.fish,n.apports),dimnames=list(years[forproj.styr:n.year],fish,apport.names))
sd_4 <- array(data=NA,dim=c(length(forproj.styr:n.year),n.fish,n.apports),dimnames=list(years[forproj.styr:n.year],fish,apport.names))
#calculate things
mean_ABC_allgear <- apply(AM_EM_abc[forproj.styr:n.year,,,,],c(1,2,5),mean)
median_ABC_allgear <- apply(AM_EM_abc[forproj.styr:n.year,,,,],c(1,2,5),median)
tempsd <- apply(AM_EM_abc[forproj.styr:n.year,,,,],c(1,2,4,5),sum)

#calc sd 
for(y in 1:length(forproj.styr:n.year)){
  for(f in 1:n.fish){
  for(b in 1:n.apports){
sd_4[y,f,b] <- sd(tempsd[y,f,,b])
  }}}
#then fill in uci and lci 
for(y in 1:length(forproj.styr:n.year)){
  for(b in 1:n.apports){
meanABC_lci_allgear[y,2,b] <- mean_ABC_allgear[y,2,b] - (1.96*sd_4[y,2,b])
meanABC_uci_allgear[y,2,b] <- mean_ABC_allgear[y,2,b] + (1.96*sd_4[y,2,b])
meanABC_lci_allgear[y,3,b] <- mean_ABC_allgear[y,3,b] - (1.96*sd_4[y,3,b])
meanABC_uci_allgear[y,3,b] <- mean_ABC_allgear[y,3,b] + (1.96*sd_4[y,3,b])
  }}
#then plot
par(mfrow=c(3,2))
for(b in 1:n.apports){
plot(mean_ABC_allgear[,2,b]~years[forproj.styr:n.year],typ="l",col="black",lwd=3,ylim=c(0,10),ylab=c("ABC (kt)"), xlab=c("Sim year"),main=paste(c(apport.names[b], "Area", areas[m])))
  lines(mean_ABC_allgear[,3,b]~years[forproj.styr:n.year],typ="l",col="blue",lwd=3)
  lines(median_ABC_allgear[,2,b]~years[forproj.styr:n.year],typ="l",col="red",lwd=3)
  lines(median_ABC_allgear[,3,b]~years[forproj.styr:n.year],lty=3,col="red",lwd=3)
  lines(meanABC_uci_allgear[,2,b]~years[forproj.styr:n.year],lty=3,col="grey",lwd=1)
  lines(meanABC_lci_allgear[,2,b]~years[forproj.styr:n.year],lty=3,col="grey",lwd=1)
  lines(meanABC_uci_allgear[,3,b]~years[forproj.styr:n.year],lty=3,col="grey",lwd=1)
  lines(meanABC_lci_allgear[,3,b]~years[forproj.styr:n.year],lty=3,col="grey",lwd=1)
legend("topright",legend=c("Mean ABC Fixed Gear","Mean ABC Trawl Gear","Median ABC Fixed Gear","Median ABC Trawl Gear","Upper & Lower ~95% CI"),lwd=c(3,3,3,3,1,1),col=c("black","blue","red","red","grey","grey"),lty=c(1,1,1,3,1,1,1,1),cex=0.5)
}
```
  
Next we examine the proportion of years (terminal year of EM runs) and sims where apportioned ABC summed over areas is above a specified threshold value. It is simple to change the threshold value being evaluated; the present value of the ABC threshold for management areas combined is:
``` {r, echo=FALSE}
threshold_allA <- 12.0 #value in kilotons
threshold <- 2.0
```
`r threshold_allA` kilotons.  

The proportion of years and simulations where total ABC is above the all-area threshold is
``` {r,echo=FALSE}
AM_EM_abc_sum <- apply(AM_EM_abc[forproj.styr:n.year,,,,],c(1,4,5),sum)
dimnames(AM_EM_abc_sum)<-list(forproj.styr:n.year,sims,apport.names)
app_num <- array(data=NA,dim=c(length(forproj.styr:n.year),n.sims,n.apports),dimnames=list(forproj.styr:n.year,sims,apport.names))
for(b in 1:n.apports){
  for(i in 1:n.sims){
    for(y in 1:length(forproj.styr:n.year)){
      if(AM_EM_abc_sum[y,i,b] < threshold_allA) { #0 if below threshold
        app_num[y,i,b] <- 0      
      } else {
      app_num[y,i,b] <- 1        #if above threshold
      }
    }
  }
}
#proportion years in each area above threshold across all years and sims 
temp_a <- vector() 
temp_a <- apply(app_num[,,],3,sum)
(temp_a1 <- temp_a/(n.sims*(length(forproj.styr:n.year))) ) 
```


It may also be of value to set a threshold for individual management areas. We are presenting results for a threshold of `r threshold` kilotons.
``` {r, echo=FALSE}
AM_EM_abc_sum2 <- apply(AM_EM_abc[forproj.styr:n.year,,,,],c(1,3,4,5),sum)
dimnames(AM_EM_abc_sum2)<-list(forproj.styr:n.year,areas,sims,apport.names)
app_num2 <- array(data=NA,dim=c(length(forproj.styr:n.year),n.area,n.sims,n.apports),dimnames=list(forproj.styr:n.year,c("BS","AI","WG","CG","WY","EY/SEO"),sims,apport.names))
for(b in 1:n.apports){
  for(m in 1:n.area){
    for(i in 1:n.sims){
      for(y in 1:length(forproj.styr:n.year)){
      if(AM_EM_abc_sum2[y,m,i,b] < threshold) { #0 if below threshold
        app_num2[y,m,i,b] <- 0      
      } else {
      app_num2[y,m,i,b] <- 1        #if above threshold
      }
    }
  }
}}
#proportion years in each area above threshold across all years and sims 
temp_b <- matrix(data=NA,nrow=c(n.area),ncol=c(n.apports)) 
temp_b <- apply(app_num2,c(2,4),sum)
(temp_b1 <- temp_b/(n.sims*(length(forproj.styr:n.year))) ) 

```
  
## The stability of ABC apportionment to individual management areas and of ABC as a whole may be of interest. 
``` {r, echo=FALSE}
AM_EM_abc_sum3 <- apply(AM_EM_abc[forproj.styr:n.year,,,,],c(1,3,4,5),sum)
diff_apport <- array(data=NA,dim=c(length(forproj.styr:n.year),n.area,n.sims,n.apports),dimnames=list(forproj.styr:n.year,1:n.area,1:n.sims,apport.names))
for(b in 1:n.apports){
  for(i in 1:n.sims){
    for(m in 1:n.area){
      for(y in 1:length(forproj.styr:(n.year-1))){
    diff_apport[y,m,i,b] <- (abs(AM_EM_abc_sum3[y,m,i,b]-AM_EM_abc_sum3[y+1,m,i,b])/(abs(AM_EM_abc_sum3[y,m,i,b]+AM_EM_abc_sum3[y+1,m,i,b])/2))*100
      }}}}
diff_apport
pct_chg1 <- apply(diff_apport,c(1,2,4),mean) #mean across sims
pct_chg2 <- apply(diff_apport[1:length(forproj.styr:(n.year-1)),,,],c(2,4),mean) #mean across sims and years
pct_chg3 <- apply(diff_apport[1:length(forproj.styr:(n.year-1)),,,],4,mean)#mean across sims, areas, years
##mean decrease?
##mean increase?
```
The mean absolute percent change in ABC for each apportionment method is
```{r, echo=FALSE}
pct_chg3
```
This reflects the inherent variability in ABC from year to year.
  
Drilling down further, the mean absolute percent change in ABC for each area and apportionment method is
```{r, echo=FALSE}
pct_chg2
```
This reflects what an individual management area may experience in terms of average change in ABC from year to year.
  

## How well do apportionment methods track true (SSB) biomass proportions by area? Relative percent difference in OM biomass by area vs EM apportionment by area
``` {r, echo=FALSE}
#create arrays to hold indices
#AM_EM_natage <- array(data=NA,dim=c(n.sex,n.year,n.age,n.year,n.age,n.sims,length(1:n.apports)),dimnames=list(sexes,years,ages,years,ages,sims,apport.names))
#AM_EM_totbiomass <- array(data=NA,dim=c(n.year,n.year,n.sims,length(1:n.apports)),dimnames=list(years,years,sims,apport.names))
#read in things
#for(b in 1:n.apports){
#dir.temp <- paste0(dir.output,"/Apport.Option_",b)
#AM_EM_natage[,,,,,,b] <- readRDS(file.path(dir.temp,"EM_natage.rds")) 
#AM_EM_totbiomass[,,,b] <- readRDS(file.path(dir.temp,"EM_totbiomass.rds")) 
#}
#remember things we have read in before
#AM_EM_spbiom
#OM_ssb
#calc abc proportion by area by year and by sim and by apportionment type
temp_abc <- apply(AM_EM_abc[forproj.styr:n.year,,,,],c(1,3,4,5),sum)
ABC_prop_1 <- array(data=NA,dim=c(length(forproj.styr:n.year),n.area,n.sims,length(1:n.apports)),dimnames=list(forproj.styr:n.year,areas,sims,apport.names))
for(y in 1:(length(forproj.styr:n.year))){
  for(i in 1:n.sims){
    for(b in 1:n.apports){
    ABC_prop_1[y,,i,b] <- prop.table(temp_abc[y,,i,b])
}}}

#calc proportions OM ssbiomass by area and year
temp_abc2 <- apply(OM_ssb[,,forproj.styr:n.year,,,],c(3,4,5,6),sum)
ABC_prop_2 <- array(data=NA,dim=c(length(forproj.styr:n.year),n.area,n.sims,length(1:n.apports)),dimnames=list(forproj.styr:n.year,areas,sims,apport.names))
for(y in 1:(length(forproj.styr:n.year))){
  for(i in 1:n.sims){
    for(b in 1:n.apports){
    ABC_prop_2[y,,i,b] <- prop.table(temp_abc2[y,,i,b])
}}}

#residuals abs relative % diff (I think...lol)
resid.biomApport <- array(data=NA,dim=c(length(forproj.styr:n.year),n.area,n.sims,length(1:n.apports)),dimnames=list(forproj.styr:n.year,areas,sims,apport.names))
for(y in 1:(length(forproj.styr:n.year))){
  for(i in 1:n.sims){
    for(b in 1:n.apports){
      for(m in 1:n.area){
        resid.biomApport[y,m,i,b] <- (abs(ABC_prop_1[y,m,i,b]-ABC_prop_2[y,m,i,b])/(abs(ABC_prop_1[y,m,i,b]+ABC_prop_2[y,m,i,b])/2))*100
      }}}}
resid.biomApport
#means of em abc and OM biomass residuals and of proportions
variable.blable <- apply(resid.biomApport,c(2,4),mean) #mean absolute relative % difference between 'true' and apportioned ABC by area for each apport method (low is good if we want apportionment to track true ssb)
rownames(variable.blable)<-c("BS", "AI","WG", "CG","WY", "EY/SEO")
```
This is the mean absolute relative % difference between 'true' and apportioned ABC by area for each apport method (low is good if we want apportionment to track true ssb)
```{r, echo=FALSE}
variable.blable
```

## For each apportionment option, what is the proportion of years*sims where EM F/F40<1?
this needs to be coded after I get a new exe that spits out the values I need

## For each apportionment option, what is the proportion of years*sims where EM SSB(endyear)/B40>1? (not overfished) 
```{r, echo=FALSE}
#create arrays to hold indices
AM_EM_B40 <- array(data=NA,dim=c(n.year,n.sims,length(1:n.apports)),dimnames=list(years,sims,apport.names))
AM_EM_SBF40 <- array(data=NA,dim=c(n.year,n.sims,length(1:n.apports)),dimnames=list(years,sims,apport.names))
AM_EM_SBF35 <- array(data=NA,dim=c(n.year,n.sims,length(1:n.apports)),dimnames=list(years,sims,apport.names))
AM_EM_SBF0 <- array(data=NA,dim=c(n.year,n.sims,length(1:n.apports)),dimnames=list(years,sims,apport.names))
AM_EM_depletion1 <- array(data=NA,dim=c(n.year,n.sims,length(1:n.apports)),dimnames=list(years,sims,apport.names))
AM_EM_depletion2 <- array(data=NA,dim=c(n.year,n.sims,length(1:n.apports)),dimnames=list(years,sims,apport.names))

#read in things
for(b in 1:n.apports){
dir.temp <- paste0(dir.output,"/Apport.Option_",b)
AM_EM_B40[,,b] <- readRDS(file.path(dir.temp,"EM_B40.rds")) 
AM_EM_SBF40[,,b] <- readRDS(file.path(dir.temp,"EM_SBF40.rds")) 
AM_EM_SBF35[,,b] <- readRDS(file.path(dir.temp,"EM_SBF35.rds")) 
#AM_EM_SBF0[,,b] <- readRDS(file.path(dir.temp,"EM_SBF0.rds")) 
AM_EM_depletion1[,,b] <- readRDS(file.path(dir.temp,"EM_depletion1.rds")) 
AM_EM_depletion2[,,b] <- readRDS(file.path(dir.temp,"EM_depletion2.rds")) 
}
#remember things we have read in before
#AM_EM_spbiom
#OM_ssb
```

```{r, echo=FALSE}
#calc SSB(endyr)/B40 for each year, sim, apport
B40_ratio <- array(data=NA,dim=c(n.year,n.sims,length(1:n.apports)),dimnames=list(years,sims,apport.names))

for(y in 1:n.year){
  for(i in 1:n.sims){
    for(b in 1:n.apports){
      B40_ratio[y,i,b] <- AM_EM_spbiom[y,y,i,b]/AM_EM_B40[y,i,b] #take the EM spbiom from the terminal year of each iteration of EM over years
    }
  }
}
#mean and median and CIs for B40_ratio across years and sim by apportionment method
B40_ratio_mean <- vector()
B40_ratio_median <- vector()
B40_ratio_sd <- vector()
B40_ratio_mean <- apply(B40_ratio[forproj.styr:n.year,,],3,mean)
B40_ratio_median <- apply(B40_ratio[forproj.styr:n.year,,],3,median) 
for(b in 1:n.apports){
B40_ratio_sd[b] <- sd(B40_ratio[forproj.styr:n.year,,b])
}
melted_B40ratio <- melt(B40_ratio[forproj.styr:n.year,,],value.name="SSB_B40")
ggplot(melted_B40ratio,aes(x=Var3,y=SSB_B40)) +#,fill=Apportionment)) + 
           geom_boxplot()

#mean and median and CIs forB40_ratio across sims by year and apportionment method
B40_ratio_mean2 <- matrix(data=NA,nrow=c(length(forproj.styr:n.year)),ncol=n.apports)
B40_ratio_median2 <- matrix(data=NA,nrow=c(length(forproj.styr:n.year)),ncol=n.apports)
B40_ratio_mean2 <- apply(B40_ratio[forproj.styr:n.year,,],c(1,3),mean)
B40_ratio_median2 <- apply(B40_ratio[forproj.styr:n.year,,],c(1,3),median) 
melted_B40ratio2 <- melt(B40_ratio[forproj.styr:n.year,,],value.name="SSB_B40")
names(melted_B40ratio2) <- c("Year","Sim","Apportionment.Method","SSB_B40")

melted_B40ratio2 %>%
ggplot(aes(x=factor(Apportionment.Method),y=SSB_B40,fill=factor(Year))) + 
           geom_boxplot()

melted_B40ratio2 %>%
ggplot(aes(x=factor(Year),y=SSB_B40,fill=factor(Apportionment.Method))) + 
           geom_boxplot()

#now calculate the proportion of years SSB/b40 >1
B40_props <- array(data=NA,dim=c(length(forproj.styr:n.year),n.sims,n.apports),dimnames=list(forproj.styr:n.year,sims,apport.names))
for(y in forproj.styr:n.year){
  for(i in 1:n.sims){
    for(b in 1:n.apports){
      if(B40_ratio[y,i,b] < 1.0) {
        B40_props[(y-43),i,b] <- 0
      } else{
        B40_props[(y-43),i,b] <- 1 
      }
      }
  }}
#B40_props
#proportions
B40_props2 <- matrix(data=NA,nrow=c(length(forproj.styr:n.year)),ncol=n.apports)
B40_props2 <- apply(B40_props[,,],c(1,3),sum)
B40_props3 <- B40_props2/(n.sims)
#proportion of sims where SSB_enyr (EM, all areas) > B40 for each forward year and apportionment option is:
B40_props3

#proportions apportionment methods where sims and years were > 1:
B40_props4 <- vector()
B40_props4 <- apply(B40_props[,,],3,sum)
B40_props5 <- B40_props4/(n.sims*length(forproj.styr:n.year))
#proportion of sims where SSB_enyr (EM, all areas) > B40 for each forward year and apportionment option is:
B40_props5
```


What is SSB_endyr/ssb_styr for each apportionment method?
```{r,echo=FALSE}
#AM_EM_depletion1
melted_depletion1 <- melt(AM_EM_depletion1[forproj.styr:n.year,,],value.name="Depletion")
names(melted_depletion1) <- c("Year","Sim","Apportionment.Method","Depletion")

melted_depletion1 %>%
ggplot(aes(x=factor(Apportionment.Method),y=Depletion,fill=factor(Year))) + 
           geom_boxplot()

melted_depletion1 %>%
ggplot(aes(x=factor(Year),y=Depletion,fill=factor(Apportionment.Method))) + 
           geom_boxplot()
```

## mean and median age at harvest from EM (all areas combined) (and roughly mapped to size)
```{r, echo=FALSE}

#AM_EM_natage
#  EM_LLcatchatage <<- array(dim=c(n.sex,n.year,n.age, n.year,n.age,n.sims), dimnames=list(sexes,years,ages,years,ages,sims))
#  EM_TRcatchatage <<- array(dim=c(n.sex,n.year,n.age, n.year,n.age,n.sims), dimnames=list(sexes,years,ages,years,ages,sims))

```

## mean and median catch/ABC for each area and overall

#Proportion years/sims where of the catch in area x is more than 50% (or a changeable value) fish younger than the age @50% mature
#test.age <- 4

#Mean, median (+CIs) of age and length (converted from age?) for catches (apportioned TAC) in each EM area across years and sims


